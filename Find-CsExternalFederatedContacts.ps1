<#  
    .SYNOPSIS
    This script iterates though an XML file generated by the Lync 2013 Export-CsUserData cmdlet and produces a HMTL report of external federated domains


    .DESCRIPTION
    Created by James Arber. www.UcMadScientist.com

    .NOTES
    Version             : 1.0
    Date                : 09/02/2020
    Lync Version        : Lync 2013 / Skype4B 2019
    Author              : James Arber
    Header stolen from  : Greig Sheridan who stole it from Pat Richard's amazing "Get-CsConnections.ps1"

    Instructions
    This script will pull data from an existing DocItemSet.xml from an Export-CsUserData export.
    To use it you will need to export your existing user data by running "Export-CsUserData -PoolFQDN "FEPool.UcMadScientist.com" -Filename "Export.zip" from a server in your Lync/Skype enviroment.
    Once you have, open the ZIP file and place the DocItemSet.xml in the same folder as this script.
    Run the script and it will generate a HTML report with all the domains that users have saved in their contact lists and how frequently they have been found.


    Revision History


    : v1.0: Initial Release

    Disclaimer: Whilst I take considerable effort to ensure this script is error free and wont harm your enviroment.
    I have no way to test every possible scenario it may be used in. I provide these scripts free
    to the Unified Communications community AS IS without any warranty on its appropriateness for use in
    your environment. I disclaim all implied warranties including,
    without limitation, any implied warranties of merchantability or of fitness for a particular
    purpose. The entire risk arising out of the use or performance of the sample scripts and
    documentation remains with you. In no event shall I be liable for any damages whatsoever
    (including, without limitation, damages for loss of business profits, business interruption,
    loss of business information, or other pecuniary loss) arising out of the use of or inability
    to use the script or documentation.

    Acknowledgements
    : Testing and Advice
    Greig Sheridan https://greiginsydney.com/about/ @greiginsydney

    : Auto Update Code
    Pat Richard https://ucunleashed.com @patrichard

    : Proxy Detection
    Michel de Rooij	http://eightwone.com

    : Code Signing Certificate
    DigiCert https://www.digicert.com/


    .INPUTS
    None. Find-CsExternalFederatedContacts.ps1 does not accept pipelined input.

    .OUTPUTS
    By default Find-CsExternalFederatedContacts.ps1 creates a HTML report file in the same folder it is run and cannot be piped, specifiying -NoHtml will cause the PsCustomObject to be output instead.

    .PARAMETER -DisableScriptUpdate
    Stops the script from checking online for an update and prompting the user to download. Ideal for scheduled tasks

    .PARAMETER -NoHtml
    Stops the script from generating a HTML report, instead results will be placed in the Pipeline to be picked up by another script or displayed on screeen

    .PARAMETER -FullName
    Instead of just listing the domains in the contact list, this will list every unique contact stored in every users lync/skype contact list.
    Be careful! The output of this setting will contain personal data and should be treated as such.

    .KNOWNISSUES
    Presently the script will also report the local sip domains as well as remote, this is typically the largest count
    Depending on how you export your CsUserData you may get a bunch of weird looking GUID contacts. These are from your SIP application accounts and can be safely ignored


    .LINK
    http://www.UcMadScientist.com/#todo

    .EXAMPLE

    PS C:\> Find-CsExternalFederatedContacts.ps1 -XmlFile "foo.xml"
    Runs the script against "foo.xml" and creates a HTML report called Foo.html

    PS C:\> Find-CsExternalFederatedContacts.ps1
    Runs the script and looks for the default file DocItemSet.xml and creates a HTML report called DocItemSet.html

    PS C:\> Find-CsExternalFederatedContacts.ps1 -NoHTML
    Runs the script and looks for the default file DocItemSet.xml then outputs a PSCustomObject to the Pipline containing all the federated domains.

    PS C:\> Find-CsExternalFederatedContacts.ps1 -FullName
    Runs the script and looks for the default file DocItemSet.xml then outputs html report with each federated USER instead of domain

#>
# Script Config
#Requires -Version 3
[CmdletBinding(DefaultParametersetName = 'Common')]
param(
  [Parameter(Position = 1)] [switch]$DisableScriptUpdate,
  [Parameter(Position = 2)] [switch]$Unattended,
  [Parameter(Position = 3)] [string]$LogFileLocation,
  [Parameter(Position = 4)] [switch]$NoHtml,
  [Parameter(Position = 5)] [string]$XMLFile = "DocItemSet.xml",
  [Parameter(Position = 6)] [switch]$FullName
)

#region config
[Net.ServicePointManager]::SecurityProtocol = 'tls12, tls11, tls'
If (!$LogFileLocation) 
{
  $script:LogFileLocation = $PSCommandPath -replace '.ps1', '.log'

}

[float]$ScriptVersion = '1.0'
[string]$GithubRepo = 'Find-CsExternalFederatedContacts'
[string]$GithubBranch = 'master' 
[string]$BlogPost = 'https://www.UcMadScientist.com/find-csexternalfederatedcontacts/' 
#endregion config

#region functions
Function Write-Log
{
  <#
      .SYNOPSIS
      Function to output messages to the console based on their severity and create log files

      .DESCRIPTION
      It's a logger.

      .PARAMETER Message
      The message to write

      .PARAMETER Path
      The location of the logfile.

      .PARAMETER Severity
      Sets the severity of the log message, Higher severities will call Write-Warning or Write-Error

      .PARAMETER Component
      Used to track the module or function that called "Write-Log" 

      .PARAMETER LogOnly
      Forces Write-Log to not display anything to the user

      .EXAMPLE
      Write-Log -Message 'This is a log message' -Severity 3 -component 'Example Component'
      Writes a log file message and displays a warning to the user

      .NOTES
      N/A

      .LINK
      http://www.UcMadScientist.com

      .INPUTS
      This function does not accept pipelined input

      .OUTPUTS
      This function does not create pipelined output
  #>

  PARAM
  (
    [Parameter(Mandatory)][String]$Message,
    [String]$Path = $script:LogFileLocation,
    [int]$Severity = 1,
    [string]$Component = 'Default',
    [switch]$LogOnly

  )
  $Date             = Get-Date -Format 'HH:mm:ss'
  $Date2            = Get-Date -Format 'MM-dd-yyyy'
  $MaxLogFileSizeMB = 10
  
  If(Test-Path -Path $Path)
  {
    if(((Get-ChildItem -Path $Path).length/1MB) -gt $MaxLogFileSizeMB) # Check the size of the log file and archive if over the limit.
    {
      $ArchLogfile = $Path.replace('.log', "_$(Get-Date -Format dd-MM-yyy_hh-mm-ss).lo_")
      Rename-Item -Path ren -NewName $Path -Path $ArchLogfile
    }
  }
         
  "$env:ComputerName date=$([char]34)$Date2$([char]34) time=$([char]34)$Date$([char]34) component=$([char]34)$Component$([char]34) type=$([char]34)$Severity$([char]34) Message=$([char]34)$Message$([char]34)"| Out-File -FilePath $Path -Append -NoClobber -Encoding default
  If (!$LogOnly) 
  {
    #If LogOnly is set, we dont want to write anything to the screen as we are capturing data that might look bad onscreen
      
      
    #If the log entry is just Verbose (1), output it to verbose
    if ($Severity -eq 1) 
    {
      "$Date $Message"| Write-Verbose
    }
      
    #If the log entry is just informational (2), output it to write-host
    if ($Severity -eq 2) 
    {
      "Info: $Date $Message"| Write-Host -ForegroundColor Green
    }
    #If the log entry has a severity of 3 assume it's a warning and write it to write-warning
    if ($Severity -eq 3) 
    {
      "$Date $Message"| Write-Warning
    }
    #If the log entry has a severity of 4 or higher, assume it's an error and display an error message (Note, critical errors are caught by throw statements so may not appear here)
    if ($Severity -ge 4) 
    {
      "$Date $Message"| Write-Error
    }
  }
}

Function Get-IEProxy
{
  Write-Log -Message 'Checking for proxy settings' -severity 1
  If ( (Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings').ProxyEnable -ne 0) 
  {
    $proxies = (Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings').proxyServer
    if ($proxies) 
    {
      if ($proxies -ilike '*=*') 
      {
        return $proxies -replace '=', '://' -split (';') | Select-Object -First 1
      }
      Else 
      {
        return ('http://{0}' -f $proxies)
      }
    }
    Else 
    {
      return $null
    }
  }
  Else 
  {
    return $null
  }
}

Function Get-ScriptUpdate
{
  if ($DisableScriptUpdate -eq $false) 
  {
    Write-Log -component 'Self Update' -Message 'Checking for Script Update' -severity 2
    Write-Log -component 'Self Update' -Message 'Checking for Proxy' -severity 1
    $ProxyURL = Get-IEProxy
    If ( $ProxyURL) 
    {
      Write-Log -component 'Self Update' -Message "Using proxy address $ProxyURL" -severity 1
    }
    Else 
    {
      Write-Log -component 'Self Update' -Message 'No proxy setting detected, using direct connection' -severity 1
    }
  }
  $GitHubScriptVersion = Invoke-WebRequest -Uri "https://raw.githubusercontent.com/atreidae/$GithubRepo/$GithubBranch/version" -TimeoutSec 10 -Proxy $ProxyURL
  If ($GitHubScriptVersion.Content.length -eq 0) 
  {
    Write-Log -component 'Self Update' -Message 'Error checking for new version. You can check manually here' -severity 3
    Write-Log -component 'Self Update' -Message $BlogPost -severity 2
    Write-Log -component 'Self Update' -Message 'Pausing for 5 seconds' -severity 2
    Start-Sleep -Seconds 5
  }
  else 
  { 
    if ([float]$GitHubScriptVersion.Content -gt [float]$ScriptVersion) 
    {
      Write-Log -component 'Self Update' -Message 'New Version Available' -severity 3
      #New Version available

      #Prompt user to download
      $title = 'Update Available'
      $Message = 'An update to this script is available, did you want to download it?'

      $yes = New-Object -TypeName System.Management.Automation.Host.ChoiceDescription -ArgumentList '&Yes', `
      'Launches a browser window with the update'

      $no = New-Object -TypeName System.Management.Automation.Host.ChoiceDescription -ArgumentList '&No', `
      'No thanks.'

      $options = [Management.Automation.Host.ChoiceDescription[]]($yes, $no)

      $result = $host.ui.PromptForChoice($title, $Message, $options, 0) 

      switch ($result)
      {
        0 
        {
          Write-Log -component 'Self Update' -Message 'User opted to download update' -severity 1
          Start-Process -FilePath $BlogPost
          Write-Log -component 'Self Update' -Message 'Exiting Script' -severity 3
          Exit
        }
        1 
        {
          Write-Log -component 'Self Update' -Message 'User opted to skip update' -severity 1
        }
							
      }
    }   
    Else
    {
      Write-Log -component 'Self Update' -Message "Script is up to date on $GithubBranch branch" -severity 2
    }
  }
}



Function Search-XMLData
{ 
  $Function = "Search-XMLData"
  Write-Log -Message "Processing XML data" -Component $Function -severity 2 
  #Assume we have exported and extracted the XML

  If(!(Test-path $XMLFile))
  {
    Write-Log -Message "XML File not found" -Component $Function -severity 4 
    Throw "XML Data error"
  }
  
  Try
  {
    [xml]$XML = Get-Content $XMLFile
    Write-Log "Found XML file with $($xml.DocItemSet.DocItem.count) root entity entries" -Component $Function -severity 2 
  }
  Catch
  {
    Write-Log -Message "Error importing XML file" -Component $Function -severity 4 
    Throw "XML Data error"
  }

  Write-Log "Enmumerating data" -Component $Function -severity 2 
  
  $Script:FederatedDomains = @()
  $Script:UserMemberDomain = @()

    
  #Find all the stored contacts
  $UserMembers = ($xml.GetElementsByTagName("UserMember"))
  Write-Log "Found $($UserMembers.count) UserMember entries" -Component $Function -severity 2 
  
  #Stuff them all into a format we can use
  Foreach($member in $UserMembers)
  {
    #Clean up the domains
    #xml weirdness 
    if ($fullname)
    {
      $result = ($Member.Member)
    }
    Else
    {
      $result = ($Member.Member.split("@")[1])
    }
    $Script:UserMemberDomain += $result
  }
  
  $Subscriptions = ($xml.GetElementsByTagName("PromptedSubscriber"))
  Write-Log "Found $($Subscriptions.count) Status Subscriptions" -Component $Function -severity 2 
  #Clean up the domains
  Foreach($member in $Subscriptions)
  {

    #xml weirdness
        if ($fullname)
    {
      $result = ($Member.Subscriber)
    }
    Else
    {
      $result = ($Member.Subscriber.split("@")[1])
    }
    $Script:UserMemberDomain += $result
  }

  #Count each result and put them into a PS Object for the report
  ForEach ($result in ($Script:UserMemberDomain | Sort-Object -Unique))
  {
    $Script:Domainline = @{}
    $Script:Domainline           =  New-Object -TypeName PSobject 
    $Script:Domainline | Add-Member -MemberType NoteProperty -Name "Domain" -Value $result
    $SEARCH_RESULT = $Script:UserMemberDomain|Where-Object -FilterScript {$_ -eq $result}
    $Script:Domainline | Add-Member -MemberType NoteProperty -Name "Count" -Value ($SEARCH_RESULT.Count)
    #$Script:Domainline
    $Script:FederatedDomains  += $Script:domainLine
  }

}

Function Out-HTMLReport
{ 
  Write-Log -Message "Generating HTML Report" -Component $Function -severity 2

  $function = 'End Block'
  $ReportTitle = "Federation Report"
  $ReportDate = (Get-Date -format dd.MM.yy.hh.mm)
  $Report = ($XmlFile -replace '.xml', '.html')

  $Style = @"
<style>
BODY{background-color::#b0c4de;font-family:Tahoma;font-size:12pt;}
TABLE{border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;}
TH{border-width: 1px;padding: 3px;border-style: solid;border-color: black;color:white;background-color:#000099}
TD{border-width: 1px;padding: 3px;border-style: solid;border-color: black;text-align:center;}
</style>
"@

  $Script:FederatedDomains | ConvertTo-Html -head $Style -body "<h1> $ReportTitle </h1> The following report was run on $ReportDate <p> Generated by Find-CsExternalFederatedContact.ps1 from <a href=\`"https://www.UcMadScientist.com/find-csexternalfederatedcontacts/\`">UcMadScientist.com</a>" | foreach {
    if($_ -like "*<td>OK*")
    {$_ -replace "<td>OK", "<td bgcolor=#33FF66>OK"} 
    Else {$_}
  } | Foreach {
    if($_ -like "*<td>Warn*")
    {$_ -replace "<td>Warn", "<td bgcolor=#F9E79F>Warn"}
  Else {$_} } | foreach {
    If($_ -like "*<td>Error*")
    {$_ -replace "<td>Error", "<td bgcolor=#CD6155>Error"}
    Else {$_}
  } | Out-File $Report

  Write-Log -Message "Finished generating HTML Report, Opening browser" -Component $Function -severity 2 
  invoke-Item $Report
}
#endregion functions

#Main script

#Check for update
Get-ScriptUpdate

#Ill add in auto pulling of the XML later. right now, we just pull the data from the XML
Search-XMLData

#We we dont want a HTML report, dump it on the pipeline

If ($NoHtml) {Write-Output $Script:FederatedDomains}

#Otherwise, pump out a HTML report
Else
{
  Out-HTMLReport
}

